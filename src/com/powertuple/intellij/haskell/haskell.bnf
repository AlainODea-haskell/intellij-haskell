// Derived from http://www.haskell.org/onlinereport/haskell2010/haskellch10.html
{
  parserClass="com.powertuple.intellij.haskell.parser.HaskellParser"
  parserUtilClass="com.powertuple.intellij.haskell.HaskellParserUtil"

  implements="com.powertuple.intellij.haskell.psi.HaskellCompositeElement"
  extends="com.powertuple.intellij.haskell.psi.impl.HaskellCompositeElementImpl"

  psiClassPrefix="Haskell"
  psiImplClassSuffix="Impl"
  psiPackage="com.powertuple.intellij.haskell.psi"
  psiImplPackage="com.powertuple.intellij.haskell.psi.impl"

  elementTypeHolderClass="com.powertuple.intellij.haskell.psi.HaskellTypes"
  elementTypeClass="com.powertuple.intellij.haskell.psi.HaskellCompositeElementType"
  tokenTypeClass="com.powertuple.intellij.haskell.psi.HaskellTokenType"

  psiImplUtilClass="com.powertuple.intellij.haskell.psi.impl.HaskellPsiImplUtil"

  elementTypePrefix="HS_"

  methods("type_signature|data_declaration|type_declaration")=[getIdentifier getIdentifierElement]
  implements("type_signature|data_declaration|type_declaration")="com.powertuple.intellij.haskell.psi.HaskellDeclarationElement"
}

program                     ::= (lexeme | whitespace)*
private whitespace          ::= (whitestuff)+
private whitestuff          ::= COMMENT | NCOMMENT | NEWLINE
private lexeme              ::= type_signature | start_definition | data_declaration | import_declaration | type_declaration |
                                qvar | var | qcon | con | qconsym | consym | qvarsym | varsym | literal
                                | special | reservedop | reservedid | specialreservedid

literal                     ::= DECIMAL | HEXADECIMAL | OCTAL | FLOAT | CHARACTER_LITERAL | STRING_LITERAL

private special             ::= LEFT_PAREN | RIGHT_PAREN | COMMA | SEMICOLON | LEFT_BRACKET | RIGHT_BRACKET
                                | BACKQUOTE | LEFT_BRACE | RIGHT_BRACE

private ascSymbol           ::= EXCLAMATION_MARK | HASH | DOLLAR| PERCENTAGE | AMPERSAND | STAR
                                | PLUS | DOT | SLASH | LT | EQUAL | GT | QUESTION_MARK | AT | BACKSLASH | CARET
                                | VERTICAL_BAR | TILDE | COLON | DASH

private symbol              ::= ascSymbol                   // ignoring unicode symbols

varsym                      ::= (symbol (symbol | COLON)*)    // operator
consym                      ::= (COLON (symbol | COLON)*)       // operator constructor

import_declaration          ::= IMPORT qcon {methods=[getModuleName]}

type_signature              ::= vars COLON_COLON (context DOUBLE_RIGHT_ARROW)? ttype
data_declaration            ::= DATA (context DOUBLE_RIGHT_ARROW)? simpletype EQUAL constrs (DERIVING)?
type_declaration            ::= TYPE simpletype EQUAL atype

start_definition            ::= (qvar | qcon) EQUAL

var                         ::= VAR_ID                      // variables and type variables
                                 {mixin="com.powertuple.intellij.haskell.psi.impl.HaskellNamedElementImpl"
                                  implements="com.powertuple.intellij.haskell.psi.HaskellNamedElement" methods=[getName setName getNameIdentifier getReference getPresentation]}

con                         ::= CON_ID                      // constructors, type constructors and type classes
                                 {mixin="com.powertuple.intellij.haskell.psi.impl.HaskellNamedElementImpl"
                                  implements="com.powertuple.intellij.haskell.psi.HaskellNamedElement" methods=[getName setName getNameIdentifier getPresentation]}

qvar                        ::= (con DOT)? var {methods=[getId]}
qcon                        ::= (con DOT)? con {methods=[getId]}

qvarsym                     ::= (con DOT)? varsym
qconsym                     ::= (con DOT)? consym

reservedid                  ::= CASE | CLASS | DATA | DEFAULT | DERIVING | DO | ELSE
                              | FOREIGN | IF | IMPORT | IN | INFIX | INFIXL | INFIXR
                              | INSTANCE | LET | MODULE | NEWTYPE | OF | THEN | TYPE
                              | WHERE | UNDERSCORE

reservedop                  ::= DOT_DOT | COLON | COLON_COLON | EQUAL | SLASH | VERTICAL_BAR | LEFT_ARROW
                              | RIGHT_ARROW | AT | TILDE | DOUBLE_RIGHT_ARROW

specialreservedid           ::= AS | QUALIFIED | HIDING | INCLUDE

vars                        ::= var (COMMA var)*
simpletype                  ::= con (var)* {methods=[getId]}
context                     ::= (con var | (LEFT_PAREN con var (COMMA con var)* RIGHT_PAREN))
ttype                       ::= atype+ (RIGHT_ARROW atype+)*
atype                       ::= (var | con | special | DOT )

constrs                     ::= constr (VERTICAL_BAR constr)*
constr                      ::= (atype | EXCLAMATION_MARK | COLON_COLON)+