// Derived from http://www.haskell.org/onlinereport/haskell2010/haskellch10.html
{
  parserClass="com.powertuple.intellij.haskell.parser.HaskellParser"
  parserUtilClass="com.powertuple.intellij.haskell.HaskellParserUtil"

  implements="com.powertuple.intellij.haskell.psi.HaskellCompositeElement"
  extends="com.powertuple.intellij.haskell.psi.impl.HaskellCompositeElementImpl"

  psiClassPrefix="Haskell"
  psiImplClassSuffix="Impl"
  psiPackage="com.powertuple.intellij.haskell.psi"
  psiImplPackage="com.powertuple.intellij.haskell.psi.impl"

  elementTypeHolderClass="com.powertuple.intellij.haskell.psi.HaskellTypes"
  elementTypeClass="com.powertuple.intellij.haskell.psi.HaskellCompositeElementType"
  tokenTypeClass="com.powertuple.intellij.haskell.psi.HaskellTokenType"

  psiImplUtilClass="com.powertuple.intellij.haskell.psi.impl.HaskellPsiImplUtil"

  elementTypePrefix="HS_"

  methods("qvar_id|qvar_sym|qcon_id|gcon_sym")=[getName setName getNameIdentifier getReference getPresentation]
  mixin("qvar_id|qvar_sym|qcon_id|gcon_sym")="com.powertuple.intellij.haskell.psi.impl.HaskellNamedElementImpl"
  implements("qvar_id|qvar_sym|qcon_id|gcon_sym")="com.powertuple.intellij.haskell.psi.HaskellNamedElement"

  methods("type_signature_declaration|data_declaration|type_declaration|newtype_declaration|class_declaration|instance_declaration|type_family_declaration|deriving_declaration|type_instance_declaration")=[getName getPresentation getIdentifierElements]
  implements("type_signature_declaration|data_declaration|type_declaration|newtype_declaration|class_declaration|instance_declaration|type_family_declaration|deriving_declaration|type_instance_declaration")="com.powertuple.intellij.haskell.psi.HaskellDeclarationElement"
}

program                     ::= onl language_pragmas? onl module_body
language_pragmas            ::= (language_pragma onl)+
language_pragma             ::= PRAGMA_START osnl qcon_id osnl qcon_id (osnl COMMA osnl qcon_id)* osnl PRAGMA_END NEWLINE

other_pragma                ::= PRAGMA_START (general_id | NEWLINE)+ PRAGMA_END NEWLINE
module_body                 ::= module_declaration+ onl body | body
module_declaration          ::= MODULE qcon_id onl WHERE? onl (onl exports)? onl WHERE? onl               {methods=[getModuleName]}

private body                ::= import_declarations top_declarations
private top_declarations    ::= (top_declaration onl)*
private import_declarations ::= (import_declaration onl)*

import_declaration          ::= IMPORT import_qualified? osnl import_module osnl import_qualified_as? osnl import_spec? NEWLINE    {methods=[getModuleName]}
import_module               ::= qcon_id
import_qualified            ::= qvar_id
import_qualified_as         ::= qvar_id qcon_id
import_spec                 ::= import_ids_spec |
                                  import_hiding_spec |
                                  import_empty_spec

import_ids_spec             ::= LEFT_PAREN osnl import_id (osnl COMMA osnl import_id)* osnl (COMMA)? osnl RIGHT_PAREN
import_hiding_spec          ::= import_hiding osnl LEFT_PAREN osnl (import_id osnl (osnl COMMA osnl import_id)* osnl (COMMA)?)? osnl RIGHT_PAREN
import_empty_spec           ::= LEFT_PAREN RIGHT_PAREN
import_hiding               ::= qvar_id
import_id                   ::= TYPE? qvar |
                                  qcon osnl (DOT_DOT_PARENS | LEFT_PAREN osnl (cname osnl (COMMA osnl cname)*)? osnl RIGHT_PAREN)?

top_declaration             ::= type_declaration | data_declaration | newtype_declaration | class_declaration | instance_declaration | default_declaration |
                                  foreign_declaration | type_family_declaration | deriving_declaration | type_instance_declaration | type_signature_declaration | expression | other_pragma

type_declaration            ::= TYPE osnl simpletype osnl (EQUAL | WHERE)? osnl (ttype | type_signature)? (DOUBLE_RIGHT_ARROW ttype)? NEWLINE
data_declaration            ::= DATA osnl (context osnl DOUBLE_RIGHT_ARROW)? osnl simpletype osnl (EQUAL osnl constrs | (WHERE | EQUAL) osnl cdecls)? osnl (DERIVING osnl ttype)? NEWLINE
newtype_declaration         ::= NEWTYPE osnl (context osnl DOUBLE_RIGHT_ARROW)? osnl simpletype osnl EQUAL osnl newconstr osnl (DERIVING osnl ttype)? NEWLINE
class_declaration           ::= (CLASS osnl (scontext osnl DOUBLE_RIGHT_ARROW)? osnl qcon_id osnl
                                    (qvar_id | LEFT_PAREN type_signature RIGHT_PAREN)*
                                    (osnl VERTICAL_BAR osnl ttype (osnl COMMA osnl ttype)*)? osnl WHERE? osnl cdecls? |
                                  CLASS osnl context osnl DOUBLE_RIGHT_ARROW osnl qcon_id osnl qvar_id osnl WHERE? osnl cdecls?) NEWLINE     // seen in Control.Lens.Internal.Indexed

instance_declaration        ::= INSTANCE osnl (scontext osnl DOUBLE_RIGHT_ARROW)? osnl qcon_id osnl inst osnl WHERE? osnl idecls? NEWLINE
default_declaration         ::= DEFAULT osnl (LEFT_PAREN (ttype (COMMA ttype)*)? RIGHT_PAREN | type_signature) NEWLINE
type_instance_declaration   ::= TYPE_INSTANCE osnl expression
type_signature_declaration  ::= type_signature NEWLINE
type_signature              ::= (vars osnl COLON_COLON osnl ((ttype | context) DOUBLE_RIGHT_ARROW)? osnl ttype | fixity (DECIMAL)? ops)   {methods=[getIdentifierElements]}
foreign_declaration         ::= (FOREIGN_IMPORT | FOREIGN_EXPORT) osnl expression
type_family_declaration     ::= TYPE_FAMILY osnl type_family_type osnl WHERE? osnl expression?
deriving_declaration        ::= DERIVING INSTANCE (scontext osnl DOUBLE_RIGHT_ARROW)? osnl qcon_id osnl inst NEWLINE

literal                     ::= DECIMAL | HEXADECIMAL | OCTAL | FLOAT | CHARACTER_LITERAL | STRING_LITERAL

private nl                  ::= NEWLINE+                              // new lines
private onl                 ::= NEWLINE*                              // optional new lines
private osnl                ::= (&<<containsSpaces>> NEWLINE)*        // optional multiple new line and spaces
snl                         ::= (&<<containsSpaces>> NEWLINE)+        // multiple new line and spaces

comments                    ::= COMMENT | NCOMMENT | NCOMMENT_START | NCOMMENT_END

qvar_id                     ::= QVARID_ID
qcon_id                     ::= QCONID_ID | LEFT_BRACKET qvar_id? RIGHT_BRACKET
qvar_sym                    ::= QVARSYM_ID | TILDE // added tilde because: data (~) a b = Eq# ((~#) a b) in Types.hs in ghc-prim
gcon_sym                    ::= GCONSYM_ID

qvar                        ::= qvar_id | LEFT_PAREN qvar_sym RIGHT_PAREN     {methods=[getIdentifierElement getName]}        // qualified variables and type variables
qcon                        ::= qcon_id | LEFT_PAREN gcon_sym RIGHT_PAREN     {methods=[getIdentifierElement getName]}        // qualified constructors, type constructors, modules and type classes

qvarop                      ::= qvar_sym | BACKQUOTE qvar_id BACKQUOTE        {methods=[getIdentifierElement getName]}        // qualified variable operator
qconop                      ::= gcon_sym | BACKQUOTE qcon_id BACKQUOTE        {methods=[getIdentifierElement getName]}        // qualified constructor operator

vars                        ::= qvar (COMMA qvar)*

op                          ::= qvarop | qconop     {methods=[getIdentifierElement]}
ops                         ::= op (COMMA op)*

gtycon                      ::= qcon_id | LEFT_PAREN RIGHT_ARROW RIGHT_PAREN | LEFT_PAREN RIGHT_PAREN | QUOTE? LEFT_BRACKET RIGHT_BRACKET |LEFT_PAREN COMMA (COMMA)* RIGHT_PAREN

cname                       ::= qvar | qcon

private constrs             ::= constr (osnl VERTICAL_BAR osnl constr)*
private constr              ::= (constr1 | constr2 | constr3 | constr4)
constr1                     ::= qcon osnl LEFT_BRACE osnl (onl fielddecl (onl COMMA? onl fielddecl)*)? onl RIGHT_BRACE
constr2                     ::= sub_constr2 osnl qconop osnl sub_constr2
constr3                     ::= qcon osnl (qvar_sym? osnl atype)*
constr4                     ::= qvar_id gcon_sym qcon_id  // added because second data constructor in: data [] a = [] | a : [a] in Types.hs in ghc-prim
sub_constr2                 ::= (btype | qvar_sym atype)

fielddecl                   ::= vars COLON_COLON (ttype | qvar_sym atype)

private atype               ::= qvar_id (qvar_id | ttype | LEFT_PAREN type_signature RIGHT_PAREN)* (DOUBLE_RIGHT_ARROW ttype)? |  // this is forall declaration, so first qvar_id is 'forall'
                                  LEFT_PAREN qvar_id TILDE qvar_id RIGHT_PAREN (DOUBLE_RIGHT_ARROW ttype)? |
                                  LEFT_PAREN osnl ttype (osnl COMMA osnl ttype)+ osnl RIGHT_PAREN |
                                  LEFT_BRACKET osnl ttype osnl RIGHT_BRACKET |
                                  LEFT_PAREN osnl ttype+ osnl RIGHT_PAREN |
                                  gtycon |
                                  qvar_id |
                                  qcon_id |
                                  qvar_sym |
                                  gcon_sym

ttype                       ::= btype (osnl RIGHT_ARROW osnl ttype)? | parallel_array_type

private btype               ::= atype+     // generalization because left recursiveness is not supported

simpletype                  ::= parallel_array_type qvar_id  |
                                  qcon_id? ttype |
                                  qcon_id osnl qvar_id* osnl (LEFT_PAREN type_signature RIGHT_PAREN)+ osnl qvar_id* |
                                  (qcon_id | qvar_id)+ |
                                  qvar_id* osnl (LEFT_PAREN qvar_sym RIGHT_PAREN | LEFT_PAREN gcon_sym RIGHT_PAREN) osnl qvar_id*       {methods=[getIdentifierElements]}

parallel_array_type         ::= LEFT_BRACKET COLON_COLON RIGHT_BRACKET

type_family_type            ::= (type_family_type1 | type_family_type2 | LEFT_PAREN? vars COLON_COLON? osnl (context DOUBLE_RIGHT_ARROW)? osnl ttype? RIGHT_PAREN?)+ (COLON_COLON osnl ttype)?
type_family_type1           ::= qcon_id
type_family_type2           ::= qvar_sym

context                     ::= LEFT_PAREN osnl (clazz (osnl COMMA osnl clazz)*)? osnl RIGHT_PAREN |
                                  clazz

clazz                       ::= qcon_id qvar_id+ |
                                  qcon_id LEFT_PAREN qvar_id atype+ RIGHT_PAREN |
                                  qcon_id LEFT_PAREN qcon_id qvar_id RIGHT_PAREN

scontext                    ::= simpleclass? LEFT_PAREN osnl simpleclass osnl (osnl COMMA osnl simpleclass)* osnl RIGHT_PAREN |
                                  simpleclass

simpleclass                 ::= simpleclass_tilde_part TILDE simpleclass_tilde_part |
                                LEFT_PAREN simpleclass_tilde_part TILDE simpleclass_tilde_part RIGHT_PAREN |
                                  qcon_id+ qvar_id+ |
                                  atype

simpleclass_tilde_part      ::= (qcon_id LEFT_PAREN qcon_id qvar_id RIGHT_PAREN)? qvar_id+ | qcon_id qvar_id*

inst                        ::= qvar_id gtycon |
                                  gtycon? instvar* (LEFT_PAREN osnl gtycon (instvar)* osnl RIGHT_PAREN)+ instvar* |
                                  gtycon+ instvar* |
                                  qvar_id instvar* |
                                  (LEFT_PAREN osnl instvar (osnl COMMA osnl instvar)+ osnl RIGHT_PAREN)+ instvar* |
                                  (LEFT_BRACKET osnl instvar osnl RIGHT_BRACKET)+ |
                                  (LEFT_PAREN osnl instvar+ osnl RIGHT_PAREN)+ instvar* |
                                  (LEFT_PAREN osnl instvar+ (RIGHT_ARROW osnl instvar* osnl)* osnl RIGHT_PAREN)+ instvar*

instvar                     ::= qcon_id | qvar_id | gcon_sym | LEFT_BRACKET qvar_id RIGHT_BRACKET | LEFT_PAREN qvar_id? (gcon_sym | qcon_id) qvar_id? RIGHT_PAREN | LEFT_PAREN RIGHT_PAREN

fixity                      ::= INFIXL | INFIXR | INFIX

exports                     ::= LEFT_PAREN onl export? onl (onl COMMA? onl export onl)* onl COMMA? onl RIGHT_PAREN
export                      ::= export1 | export2 | export3
private export1             ::= TYPE? onl qvar
private export2             ::= qcon onl (DOT_DOT_PARENS | LEFT_PAREN onl (cname onl (onl COMMA onl cname)*)? onl RIGHT_PAREN)?
private export3             ::= MODULE qcon_id

newconstr                   ::= qcon atype | qcon osnl LEFT_BRACE osnl qvar COLON_COLON ttype osnl RIGHT_BRACE

private cdecls              ::= cdecl (snl cdecl)*
cdecl                       ::= (type_signature | cidecl)

private idecls              ::= idecl (snl idecl)*
idecl                       ::= qvar? cidecl

private cidecl              ::= (general_id | TYPE | NEWTYPE | DEFAULT)+

expression                  ::= first_line_expression (line_expression)* last_line_expression | last_line_expression
first_line_expression       ::= general_id+ snl
line_expression             ::= general_id+ snl
last_line_expression        ::= general_id+ osnl

private general_id          ::= (qvar_id | qcon_id | qvar_sym | gcon_sym | LEFT_PAREN | RIGHT_PAREN | FLOAT | DO | WHERE | IF | THEN | ELSE |
                                 COLON_COLON | DOUBLE_RIGHT_ARROW | ttype | context | RIGHT_ARROW | IN | CASE | OF | LET |
                                 SEMICOLON | LEFT_ARROW | LEFT_BRACKET | RIGHT_BRACKET | literal | LEFT_BRACE | RIGHT_BRACE |
                                 COMMA | UNDERSCORE | symbol_reserved_op | QUOTE | BACKQUOTE | fixity)

private symbol_reserved_op  ::= AT | BACKSLASH | VERTICAL_BAR | TILDE | EQUAL  // except 'colon' because handled as symbol